(* $Log: tiger.grm,v $
 * Revision 1.4  2012/02/15 22:09:02  csun
 * added log
 * *)

structure A = Absyn

fun sym s = Symbol.symbol s

fun makeBinExp(left,oper,right,pos) = 
    A.OpExp{left = left,
	    oper = oper,
	    right = right,
	    pos = pos}

type tydec = {name: A.symbol, ty: A.ty, pos: A.pos}

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | UMINUS | DEC

%nonterm program of A.exp
	| exp of A.exp
	| decs of A.dec list
	| tydec of tydec
	| tydecs of tydec list
	| vardec of A.dec
	| fundec of A.fundec
	| fundecs of A.fundec list
	| ty of A.ty
	| tyfs of A.field list
	| tyfs_t of A.field list
	| args of A.exp list
	| args_t of A.exp list
	| rcd of (A.symbol * A.exp * A.pos) list
	| rcd_t of (A.symbol * A.exp * A.pos) list
	| lval of A.var
	| lval_t of A.var
	| exp_seq of (A.exp * A.pos) list
	| exp_seq_t of (A.exp * A.pos) list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc DEC
%nonassoc TYPE FUNCTION

%right OF
%nonassoc DO
%nonassoc ELSE
%nonassoc ASSIGN
%left AND OR
%nonassoc EQ NEQ LT GT LE GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

program	: exp			(exp)

decs : 			(nil)
     | tydecs decs 	([A.TypeDec(tydecs)]@decs)
     | vardec decs	([vardec]@decs)
     | fundecs decs 	([A.FunctionDec(fundecs)]@decs)

tydecs : tydec	%prec DEC	([tydec])
       | tydec tydecs	([tydec]@tydecs)

tydec : TYPE ID EQ ty
		({name = sym(ID),
		  ty = ty,
		  pos = TYPEleft})

ty : ID			(A.NameTy(sym(ID),IDleft))
   | LBRACE tyfs RBRACE	(A.RecordTy(tyfs))
   | ARRAY OF ID	(A.ArrayTy(sym(ID),ARRAYleft))

tyfs : 				(nil)
     | ID COLON ID tyfs_t
		([{name = sym(ID1),
		   escape = ref true,
		   typ = sym(ID2),
		   pos = ID1left}]@tyfs_t)

tyfs_t : 				(nil)
       | COMMA ID COLON ID tyfs_t
		([{name = sym(ID1),
		   escape = ref true,
		   typ = sym(ID2),
		   pos = COMMAleft}]@tyfs_t)

vardec : VAR ID ASSIGN exp 	
		(A.VarDec{name = sym(ID),
			  escape = ref true,
			  typ = NONE,
			  init = exp,
			  pos = VARleft})
       | VAR ID COLON ID ASSIGN exp
		(A.VarDec{name = sym(ID1),
			  escape = ref true,
			  typ = SOME(sym(ID2),ID2left),
			  init = exp,
			  pos = VARleft})
	     
fundec : FUNCTION ID LPAREN tyfs RPAREN EQ exp
		({name = sym(ID),
		  params = tyfs,
		  result = NONE,
		  body = exp,
		  pos = FUNCTIONleft})
       | FUNCTION ID LPAREN tyfs RPAREN COLON ID EQ exp
		({name = sym(ID1),
		  params = tyfs,
		  result = SOME(sym(ID2),ID2left),
		  body = exp,
		  pos = FUNCTIONleft})

fundecs : fundec %prec DEC	([fundec])
	| fundec fundecs	([fundec]@fundecs)
		 
args : 	(nil)
     | exp args_t	([exp]@args_t)
	   
args_t : 		(nil)
       | COMMA exp args_t	([exp]@args_t)
	       
rcd : 	(nil)
    | ID EQ exp rcd_t	([(sym(ID),exp,IDleft)]@rcd_t)
	 
rcd_t : 			(nil)
      | COMMA ID EQ exp rcd_t		([(sym(ID),exp,IDleft)]@rcd_t)
	      
lval : ID	(A.SimpleVar(sym(ID),IDleft))
     | lval_t	(lval_t)
		
lval_t : ID DOT ID
		(A.FieldVar(A.SimpleVar(sym(ID1),ID1left),
			    sym(ID2),ID1left))
	 
       | lval_t DOT ID	(A.FieldVar(lval_t,sym(ID),lval_tleft))
       | ID LBRACK exp RBRACK		(A.SubscriptVar(A.SimpleVar(sym(ID),IDleft),
							exp,IDleft))
       | lval_t LBRACK exp RBRACK	(A.SubscriptVar(lval_t,exp,lval_tleft))
		
exp: lval			(A.VarExp(lval))
   | NIL			(A.NilExp)
   | INT			(A.IntExp(INT))
   | STRING			(A.StringExp(STRING,STRINGleft))
   | MINUS exp %prec UMINUS	(A.OpExp{left = A.IntExp(0),
					 oper = A.MinusOp,
					 right = exp, 
					 pos = MINUSleft})
   | LPAREN exp_seq RPAREN	(A.SeqExp(exp_seq))
   | ID LPAREN args RPAREN	(A.CallExp{func = sym(ID),
					   args = args,
					   pos = IDleft})
   | ID LBRACE rcd RBRACE		(A.RecordExp{fields = rcd,
						     typ = sym(ID),
						     pos = IDleft})
   | ID LBRACK exp RBRACK OF exp  	(A.ArrayExp{typ = sym(ID),
						    size = exp1,
						    init = exp2,
						    pos = IDleft})
   | lval ASSIGN exp 		(A.AssignExp{var = lval,
					     exp = exp,
					     pos = lvalleft})
   | IF exp THEN exp ELSE exp	(A.IfExp{test = exp1,
					 then' = exp2,
					 else' = SOME(exp3),
					 pos = IFleft})
   | IF exp THEN exp %prec DO	(A.IfExp{test = exp1,
					 then' = exp2,
					 else' = NONE,
					 pos = IFleft})
   | WHILE exp DO exp		(A.WhileExp{test = exp1,
					    body = exp2,
					    pos = WHILEleft})
   | FOR ID ASSIGN exp TO exp DO exp 	(A.ForExp{var = sym(ID),
						  escape = ref true,
						  lo = exp1,
						  hi = exp2,
						  body = exp3,
						  pos = FORleft})
   | BREAK				(A.BreakExp(BREAKleft))
   | LET decs IN exp_seq END	(A.LetExp{decs = decs,
					  body = A.SeqExp(exp_seq),
					  pos = LETleft})
   | exp PLUS exp		(makeBinExp(exp1,A.PlusOp,
					    exp2,exp1left))
   | exp MINUS exp		(makeBinExp(exp1,A.MinusOp,
					    exp2,exp1left))
   | exp DIVIDE exp		(makeBinExp(exp1,A.DivideOp,
					    exp2,exp1left))  	
   | exp TIMES exp 		(makeBinExp(exp1,A.TimesOp,
					    exp2,exp1left))
   | exp EQ exp 		(makeBinExp(exp1,A.EqOp,
					    exp2,exp1left))
   | exp NEQ exp 		(makeBinExp(exp1,A.NeqOp,
					    exp2,exp1left))
   | exp GT exp 		(makeBinExp(exp1,A.GtOp,
					    exp2,exp1left))
   | exp LT exp 		(makeBinExp(exp1,A.LtOp,
					    exp2,exp1left))
   | exp GE exp 		(makeBinExp(exp1,A.GeOp,
					    exp2,exp1left))
   | exp LE exp 		(makeBinExp(exp1,A.LeOp,
					    exp2,exp1left))
   | exp AND exp 		(A.IfExp{test = exp1,
					 then' = exp2,
					 else' = SOME(A.IntExp(0)),
					 pos = exp1left})
   | exp OR exp 		(A.IfExp{test = exp1,
					 then' = A.IntExp(1),
					 else' = SOME(exp2),
					 pos = exp1left})
	 
exp_seq : 			(nil)	(* no value *)
	| exp exp_seq_t		([(exp,expleft)]@exp_seq_t)
	      
exp_seq_t : 				(nil)
	  | SEMICOLON exp exp_seq_t	([(exp,expleft)]@exp_seq_t)
